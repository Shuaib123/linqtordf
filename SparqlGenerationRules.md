#summary Rules for building SPARQL queries out of LINQ queries.
## Introduction ##

This covers the syntactic process of representing the same query in SPARQL as is represented in a LINQ query, but also rules for generating identifiers, URIs, FILTERs, UNIONs and other aspects of well-formed RDF.

The example syntax for this page is based upon the [Track](http://linqtordf.googlecode.com/svn/trunk/src/unit-testing/rdf-music/Track.cs) class
## Typographic Conventions ##
The following typographic convention is employed to represent the structure of a LINQ Expression tree:
  * Naming
> Expressions are generally named XYZExpression. In this document the Expression type will be abbreviated to XYZ. Therefore an `OrElseExpression` would be referred to as `OrElse`.
  * Sub-expressions
> A Unary Expression will have an Operand which will be represented inside of a set of square brackets, like so:
```
  Not[X]
```

> A binary expression will have Left and Right properties. These are included in square brackets separated by a comma:
```
OrElse[X, Y]
```

So (A && B) || (C && D) might be represented like so:
```
  OrElse[AndAlso[A, B], AndAlso[C, D]]
```

  * ConstantExpressions
> Constant expressions will be represented by just enclosing the value inside of a set of Square Brackets. So a ConstantExpression containing the integer value 5 will be shown by `[5]`.

  * MemberAccess
> Member access will just be represented in the usual object oriented convention. If there is a parameter called `X`, then its method `GetAllFoos()`, would be represented by `X.GetAllFoos()`. If we had a query
```
  from x in y where x.Age >= 21 select x
```
then the representation of the expression passed by Queryable.Where would be
```
  GE[x.Age, [21]]
```

In addition we can also represent the parameters to the method as with the relational operators.A typical example is string equality which is passed in as `string.op_Equality`. This can be represented as `string.op_Equality[X.Name, [hello world]]` which would be equalivalent to the code `X.Name == "hello world"`.

The conventions above are sufficient to represent, tersely, the structure of simple relational and assignment expressions. More complex formulations are required for language meta instructions.

  * Lambda Expressions
  * New Expression
  * Member Init Expression
## Basic Principles ##
The following section shows how basic expression tree fragments should be turned into SPARQL. In most cases the operator gets expanded into the FILTER section of the query.

Consult The SPARQL operator mappings [table](http://www.w3.org/TR/rdf-sparql-query/#OperatorMapping) for a definition of how the operators in SPARQL get handled at the far end.

### Relational Operators ###
  * X == Y
> `X==Y` and `string.op_Equality[X,Y]` should be rendered the same:
    * `EQ[X,Y]`
```
	SELECT ?name ?age WHERE {
	?X a:Name ?name .
	?X a:Age ?age .
	FILTER {?name = "Y"^^xsdt:string}
	}
```

  * `string.op_Equality[X, [Y]]`
```
	SELECT ?name ?age WHERE {
	?X a:Name ?name .
	?X a:Age ?age .
	FILTER {?name = "Y"^^xsdt:string}
	}
```
    * `NE[X,Y]`
```
  SELECT ?name ?age WHERE {
  ?X a:Name ?name .
  ?X a:Age ?age .
  FILTER {?name != "Y"^^xsdt:string}
  }
```
    * `GT[X.Age,[5]]`
```
  SELECT ?name ?age WHERE {
  ?X a:Name ?name .
  ?X a:Age ?age .
  FILTER {?age > 5^^xsdt:int}
  }
```
    * `LT[X.Age,[5]]`
```
  SELECT ?name ?age WHERE {
  ?X a:Name ?name .
  ?X a:Age ?age .
  FILTER {?age < 5^^xsdt:int}
  }
```
    * `GE[X.Age,[5]]`
```
  SELECT ?name ?age WHERE {
  ?X a:Name ?name .
  ?X a:Age ?age .
  FILTER {?age >= 5^^xsdt:int}
  }
```
    * `LE[X.Age,[5]]`
```
  SELECT ?name ?age WHERE {
  ?X a:Name ?name .
  ?X a:Age ?age .
  FILTER {?age <= 5^^xsdt:int}
  }
```
    * `Eq[X.IsEligible, Not[GE[X.Age, [21]]]`
> > produced by code like `from X.IsEligible == !(X.Age > 21)`
```
  SELECT ?name ?age WHERE {
  ?X a:Name ?name .
  ?X a:Age ?age .
  ?X a:isEligible ?isEligible .
  FILTER {?isEligible = !(?age >= 21^^xsdt:int)}
  }
```


## LINQ Query Examples ##

The following is a list of possible LINQ queries. Each is followed by a sample of the SPARQL that should be generated by LINQ to RDF.

  * Select all
```
IRdfQuery<Track> qry = new RDF(ts).ForType<Track>(); 
var q = from t in qry
	select new t;
```
    * Should produce SPARQL similar to the following:
```
@prefix a: <http://aabs.purl.org/ontologies/2007/04/music#> .
@prefix xsdt: <http://xsdtUri> .
@prefix rdfs: <http://rdfsUri> .

SELECT _:Title _:ArtistName _:AlbumName _:Year _:GenreName _:Comment _:FileLocation _:Rating
WHERE {
  _:Track rdfs:type a:Track .
  _:Track a:title ?Title .
  _:Track a:artistName> ?ArtistName .
  _:Track a:albumName ?AlbumName .
  _:Track a:year ?Year .
  _:Track a:genreName ?GenreName .
  _:Track a:comment ?Comment .
  _:Track a:fileLocation ?FileLocation .
  _:Track a:rating ?Rating .
}

```
  * Select with simple where containing EqExpression
```
IRdfQuery<Track> qry = new RDF(ts).ForType<Track>(); 
var q = from t in qry
	where t.Year == 2006
	select new t;
```
    * Should produce SPARQL similar to the following:
```
@prefix a: <http://someUri> .
@prefix xsdt: <http://xsdtUri> .

SELECT ...
WHERE {

}
```
  * Select with Where containing AndAlsoExpression
```
IRdfQuery<Track> qry = new RDF(ts).ForType<Track>(); 
var q = from t in qry
	where t.Year == 2006 &&
	t.GenreName == "History 5 | Fall 2006 | UC Berkeley" 
	select new t;
```
    * Should produce SPARQL similar to the following:
```
@prefix a: <http://someUri> .
@prefix xsdt: <http://xsdtUri> .

SELECT ...
WHERE {

}
```
  * Select with Where containing simple OrElseExpression
```
IRdfQuery<Track> qry = new RDF(ts).ForType<Track>(); 
var q = from t in qry
	where t.Year == 2006 ||
	t.GenreName == "History 5 | Fall 2006 | UC Berkeley" 
	select new t;
```
    * Should produce SPARQL similar to the following:
```
@prefix a: <http://someUri> .
@prefix xsdt: <http://xsdtUri> .

SELECT ...
WHERE {

}
```
  * Select with Where containing AndAlsoExpression clauses combined by OrElseExpression
```
IRdfQuery<Track> qry = new RDF(ts).ForType<Track>(); 
var q = from t in qry
	where (t.Year == 2006 &&
	t.GenreName == "History 5 | Fall 2006 | UC Berkeley") ||
	(t.ArtistName == "Rory Blythe" && t.Year == 2007)
	select new t;
```
    * Should produce SPARQL similar to the following:
```
@prefix a: <http://someUri> .
@prefix xsdt: <http://xsdtUri> .

SELECT ...
WHERE {

}
```
  * Simple select with a projection
```
IRdfQuery<Track> qry = new RDF(ts).ForType<Track>(); 
var q = from t in qry
	select new {t.Title, t.FileLocation};
```
    * Should produce SPARQL similar to the following:
```
@prefix a: <http://someUri> .
@prefix xsdt: <http://xsdtUri> .

SELECT ...
WHERE {

}
```
  * Simple select with a projection not using same names as source properties
```
IRdfQuery<Track> qry = new RDF(ts).ForType<Track>(); 
var q = from t in qry
	select new {MyTitle = t.Title, MyFileLocation = t.FileLocation};
```
    * Should produce SPARQL similar to the following:
```
@prefix a: <http://someUri> .
@prefix xsdt: <http://xsdtUri> .

SELECT ...
WHERE {

}
```